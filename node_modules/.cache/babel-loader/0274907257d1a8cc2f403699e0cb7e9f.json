{"ast":null,"code":"import { useEffect, useState } from 'react';\n\nlet combineStoredValues = arr => arr.reduce((acc, curr) => {\n  if (curr.sku) {\n    var fromMap = acc.map[curr.sku];\n\n    if (!fromMap) {\n      acc.map[curr.sku] = fromMap = {\n        name: curr.name,\n        sku: curr.sku,\n        quanity: 0\n      };\n      acc.result.push(fromMap);\n    }\n\n    fromMap.quanity += parseFloat(curr.quanity);\n  } else {\n    acc.result.push(curr);\n  }\n\n  return acc;\n}, {\n  map: {},\n  result: []\n}).result;\n\nfunction useLocalStorage(key, initialValue) {\n  // Should either store products into global context or find a way to retrieve the values from localstorage PLUS re-render on update\n  // State to store our value\n  // Pass initial state function to useState so logic is only executed once\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from local storage by key\n      const item = window.localStorage.getItem(key); // Parse stored json or if none return initialValue\n\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      // If error also return initialValue\n      console.log(error);\n      return initialValue;\n    }\n  }); // Return a wrapped version of useState's setter function that ...\n  // ... persists the new value to localStorage.\n\n  const setValue = value => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore = value instanceof Function ? value(storedValue) : value; // Save state\n\n      setStoredValue(combineStoredValues(valueToStore)); // Save to local storage\n\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      // A more advanced implementation would handle the error case\n      console.log(error);\n    }\n  };\n\n  useEffect(() => {\n    setStoredValue(combineStoredValues(storedValue));\n  }, []);\n  console.log(storedValue);\n  return [storedValue, setValue];\n}\n\nexport default useLocalStorage; // let values = [];\n// function useLocalStorage(key) {\n//   const [state, setState] = useState(\n//     window.localStorage.getItem(key) !== null || undefined\n//       ? window.localStorage.getItem(key)\n//       : null\n//   );\n//   // Consider just having the key as a usequanity with return callbacks for setting and getting data\n//   console.log(values);\n//   useEffect(() => {\n//     window.localStorage.setItem(key, values);\n//   }, [key]);\n//   return {\n//     state,\n//     setState,\n//     addValue: useCallback((value) => {\n//       values.push(value);\n//       console.log(value);\n//     }, []),\n//   };\n// }","map":{"version":3,"sources":["E:/React_Projects/e-commerce_bicycle/src/components/custom_hooks/useLocalStorage.js"],"names":["useEffect","useState","combineStoredValues","arr","reduce","acc","curr","sku","fromMap","map","name","quanity","result","push","parseFloat","useLocalStorage","key","initialValue","storedValue","setStoredValue","item","window","localStorage","getItem","JSON","parse","error","console","log","setValue","value","valueToStore","Function","setItem","stringify"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;;AACA,IAAIC,mBAAmB,GAAIC,GAAD,IACxBA,GAAG,CAACC,MAAJ,CACE,CAACC,GAAD,EAAMC,IAAN,KAAe;AACb,MAAIA,IAAI,CAACC,GAAT,EAAc;AACZ,QAAIC,OAAO,GAAGH,GAAG,CAACI,GAAJ,CAAQH,IAAI,CAACC,GAAb,CAAd;;AACA,QAAI,CAACC,OAAL,EAAc;AACZH,MAAAA,GAAG,CAACI,GAAJ,CAAQH,IAAI,CAACC,GAAb,IAAoBC,OAAO,GAAG;AAC5BE,QAAAA,IAAI,EAAEJ,IAAI,CAACI,IADiB;AAE5BH,QAAAA,GAAG,EAAED,IAAI,CAACC,GAFkB;AAG5BI,QAAAA,OAAO,EAAE;AAHmB,OAA9B;AAKAN,MAAAA,GAAG,CAACO,MAAJ,CAAWC,IAAX,CAAgBL,OAAhB;AACD;;AACDA,IAAAA,OAAO,CAACG,OAAR,IAAmBG,UAAU,CAACR,IAAI,CAACK,OAAN,CAA7B;AACD,GAXD,MAWO;AACLN,IAAAA,GAAG,CAACO,MAAJ,CAAWC,IAAX,CAAgBP,IAAhB;AACD;;AACD,SAAOD,GAAP;AACD,CAjBH,EAkBE;AACEI,EAAAA,GAAG,EAAE,EADP;AAEEG,EAAAA,MAAM,EAAE;AAFV,CAlBF,EAsBEA,MAvBJ;;AAwBA,SAASG,eAAT,CAAyBC,GAAzB,EAA8BC,YAA9B,EAA4C;AAC1C;AACA;AAEA;AAEA,QAAM,CAACC,WAAD,EAAcC,cAAd,IAAgClB,QAAQ,CAAC,MAAM;AACnD,QAAI;AACF;AAEA,YAAMmB,IAAI,GAAGC,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4BP,GAA5B,CAAb,CAHE,CAKF;;AAEA,aAAOI,IAAI,GAAGI,IAAI,CAACC,KAAL,CAAWL,IAAX,CAAH,GAAsBH,YAAjC;AACD,KARD,CAQE,OAAOS,KAAP,EAAc;AACd;AAEAC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AAEA,aAAOT,YAAP;AACD;AACF,GAhB6C,CAA9C,CAN0C,CAwB1C;AAEA;;AAEA,QAAMY,QAAQ,GAAIC,KAAD,IAAW;AAC1B,QAAI;AACF;AAEA,YAAMC,YAAY,GAChBD,KAAK,YAAYE,QAAjB,GAA4BF,KAAK,CAACZ,WAAD,CAAjC,GAAiDY,KADnD,CAHE,CAMF;;AAEAX,MAAAA,cAAc,CAACjB,mBAAmB,CAAC6B,YAAD,CAApB,CAAd,CARE,CAUF;;AAEAV,MAAAA,MAAM,CAACC,YAAP,CAAoBW,OAApB,CAA4BjB,GAA5B,EAAiCQ,IAAI,CAACU,SAAL,CAAeH,YAAf,CAAjC;AACD,KAbD,CAaE,OAAOL,KAAP,EAAc;AACd;AAEAC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD;AACF,GAnBD;;AAoBA1B,EAAAA,SAAS,CAAC,MAAM;AACdmB,IAAAA,cAAc,CAACjB,mBAAmB,CAACgB,WAAD,CAApB,CAAd;AACD,GAFQ,EAEN,EAFM,CAAT;AAGAS,EAAAA,OAAO,CAACC,GAAR,CAAYV,WAAZ;AACA,SAAO,CAACA,WAAD,EAAcW,QAAd,CAAP;AACD;;AACD,eAAed,eAAf,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { useEffect, useState } from 'react';\r\nlet combineStoredValues = (arr) =>\r\n  arr.reduce(\r\n    (acc, curr) => {\r\n      if (curr.sku) {\r\n        var fromMap = acc.map[curr.sku];\r\n        if (!fromMap) {\r\n          acc.map[curr.sku] = fromMap = {\r\n            name: curr.name,\r\n            sku: curr.sku,\r\n            quanity: 0,\r\n          };\r\n          acc.result.push(fromMap);\r\n        }\r\n        fromMap.quanity += parseFloat(curr.quanity);\r\n      } else {\r\n        acc.result.push(curr);\r\n      }\r\n      return acc;\r\n    },\r\n    {\r\n      map: {},\r\n      result: [],\r\n    }\r\n  ).result;\r\nfunction useLocalStorage(key, initialValue) {\r\n  // Should either store products into global context or find a way to retrieve the values from localstorage PLUS re-render on update\r\n  // State to store our value\r\n\r\n  // Pass initial state function to useState so logic is only executed once\r\n\r\n  const [storedValue, setStoredValue] = useState(() => {\r\n    try {\r\n      // Get from local storage by key\r\n\r\n      const item = window.localStorage.getItem(key);\r\n\r\n      // Parse stored json or if none return initialValue\r\n\r\n      return item ? JSON.parse(item) : initialValue;\r\n    } catch (error) {\r\n      // If error also return initialValue\r\n\r\n      console.log(error);\r\n\r\n      return initialValue;\r\n    }\r\n  });\r\n\r\n  // Return a wrapped version of useState's setter function that ...\r\n\r\n  // ... persists the new value to localStorage.\r\n\r\n  const setValue = (value) => {\r\n    try {\r\n      // Allow value to be a function so we have same API as useState\r\n\r\n      const valueToStore =\r\n        value instanceof Function ? value(storedValue) : value;\r\n\r\n      // Save state\r\n\r\n      setStoredValue(combineStoredValues(valueToStore));\r\n\r\n      // Save to local storage\r\n\r\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\r\n    } catch (error) {\r\n      // A more advanced implementation would handle the error case\r\n\r\n      console.log(error);\r\n    }\r\n  };\r\n  useEffect(() => {\r\n    setStoredValue(combineStoredValues(storedValue));\r\n  }, []);\r\n  console.log(storedValue);\r\n  return [storedValue, setValue];\r\n}\r\nexport default useLocalStorage;\r\n\r\n// let values = [];\r\n// function useLocalStorage(key) {\r\n//   const [state, setState] = useState(\r\n//     window.localStorage.getItem(key) !== null || undefined\r\n//       ? window.localStorage.getItem(key)\r\n//       : null\r\n//   );\r\n\r\n//   // Consider just having the key as a usequanity with return callbacks for setting and getting data\r\n//   console.log(values);\r\n//   useEffect(() => {\r\n//     window.localStorage.setItem(key, values);\r\n//   }, [key]);\r\n\r\n//   return {\r\n//     state,\r\n//     setState,\r\n//     addValue: useCallback((value) => {\r\n//       values.push(value);\r\n//       console.log(value);\r\n//     }, []),\r\n//   };\r\n// }\r\n"]},"metadata":{},"sourceType":"module"}