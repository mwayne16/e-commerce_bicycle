{"ast":null,"code":"import { useEffect, useState, useCallback } from 'react';\nimport { initialState } from '../../reducers/productReducer';\n\nfunction useLocalStorage(key, initialValue) {\n  // Should either store products into global context or find a way to retrieve the values from localstorage PLUS re-render on update\n  // State to store our value\n  // Pass initial state function to useState so logic is only executed once\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from local storage by key\n      const item = window.localStorage.getItem(key); // Parse stored json or if none return initialValue\n\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      // If error also return initialValue\n      console.log(error);\n      return initialValue;\n    }\n  }); // Return a wrapped version of useState's setter function that ...\n  // ... persists the new value to localStorage.\n\n  const setValue = value => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore = value instanceof Function ? value(storedValue) : value; // Save state\n\n      setStoredValue(valueToStore); // Save to local storage\n\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      // A more advanced implementation would handle the error case\n      console.log(error);\n    }\n  };\n\n  console.log(storedValue);\n  let newValue = storedValue.reduce((acc, curr) => {\n    if (curr.sku) {\n      var fromMap = acc.map[curr.sku];\n\n      if (!fromMap) {\n        acc.map[curr.sku] = fromMap = {\n          quanity: 0,\n          sku: curr.sku\n        };\n        acc.newValue.push(fromMap);\n      }\n\n      fromMap.quanity += parseFloat(curr.quanity);\n    } else {\n      acc.newValue.push(curr);\n    }\n\n    return acc;\n  }, {\n    map: {},\n    result: []\n  }).result;\n  return [storedValue, setValue];\n}\n\nexport default useLocalStorage; // let values = [];\n// function useLocalStorage(key) {\n//   const [state, setState] = useState(\n//     window.localStorage.getItem(key) !== null || undefined\n//       ? window.localStorage.getItem(key)\n//       : null\n//   );\n//   // Consider just having the key as a useRef with return callbacks for setting and getting data\n//   console.log(values);\n//   useEffect(() => {\n//     window.localStorage.setItem(key, values);\n//   }, [key]);\n//   return {\n//     state,\n//     setState,\n//     addValue: useCallback((value) => {\n//       values.push(value);\n//       console.log(value);\n//     }, []),\n//   };\n// }","map":{"version":3,"sources":["E:/React_Projects/e-commerce_bicycle/src/components/custom_hooks/useLocalStorage.js"],"names":["useEffect","useState","useCallback","initialState","useLocalStorage","key","initialValue","storedValue","setStoredValue","item","window","localStorage","getItem","JSON","parse","error","console","log","setValue","value","valueToStore","Function","setItem","stringify","newValue","reduce","acc","curr","sku","fromMap","map","quanity","push","parseFloat","result"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,QAApB,EAA8BC,WAA9B,QAAiD,OAAjD;AACA,SAASC,YAAT,QAA6B,+BAA7B;;AAEA,SAASC,eAAT,CAAyBC,GAAzB,EAA8BC,YAA9B,EAA4C;AAC1C;AACA;AAEA;AAEA,QAAM,CAACC,WAAD,EAAcC,cAAd,IAAgCP,QAAQ,CAAC,MAAM;AACnD,QAAI;AACF;AAEA,YAAMQ,IAAI,GAAGC,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4BP,GAA5B,CAAb,CAHE,CAKF;;AAEA,aAAOI,IAAI,GAAGI,IAAI,CAACC,KAAL,CAAWL,IAAX,CAAH,GAAsBH,YAAjC;AACD,KARD,CAQE,OAAOS,KAAP,EAAc;AACd;AAEAC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AAEA,aAAOT,YAAP;AACD;AACF,GAhB6C,CAA9C,CAN0C,CAwB1C;AAEA;;AAEA,QAAMY,QAAQ,GAAIC,KAAD,IAAW;AAC1B,QAAI;AACF;AAEA,YAAMC,YAAY,GAChBD,KAAK,YAAYE,QAAjB,GAA4BF,KAAK,CAACZ,WAAD,CAAjC,GAAiDY,KADnD,CAHE,CAMF;;AAEAX,MAAAA,cAAc,CAACY,YAAD,CAAd,CARE,CAUF;;AAEAV,MAAAA,MAAM,CAACC,YAAP,CAAoBW,OAApB,CAA4BjB,GAA5B,EAAiCQ,IAAI,CAACU,SAAL,CAAeH,YAAf,CAAjC;AACD,KAbD,CAaE,OAAOL,KAAP,EAAc;AACd;AAEAC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD;AACF,GAnBD;;AAoBAC,EAAAA,OAAO,CAACC,GAAR,CAAYV,WAAZ;AAEA,MAAIiB,QAAQ,GAAGjB,WAAW,CAACkB,MAAZ,CACb,CAACC,GAAD,EAAMC,IAAN,KAAe;AACb,QAAIA,IAAI,CAACC,GAAT,EAAc;AACZ,UAAIC,OAAO,GAAGH,GAAG,CAACI,GAAJ,CAAQH,IAAI,CAACC,GAAb,CAAd;;AACA,UAAI,CAACC,OAAL,EAAc;AACZH,QAAAA,GAAG,CAACI,GAAJ,CAAQH,IAAI,CAACC,GAAb,IAAoBC,OAAO,GAAG;AAC5BE,UAAAA,OAAO,EAAE,CADmB;AAE5BH,UAAAA,GAAG,EAAED,IAAI,CAACC;AAFkB,SAA9B;AAIAF,QAAAA,GAAG,CAACF,QAAJ,CAAaQ,IAAb,CAAkBH,OAAlB;AACD;;AACDA,MAAAA,OAAO,CAACE,OAAR,IAAmBE,UAAU,CAACN,IAAI,CAACI,OAAN,CAA7B;AACD,KAVD,MAUO;AACLL,MAAAA,GAAG,CAACF,QAAJ,CAAaQ,IAAb,CAAkBL,IAAlB;AACD;;AACD,WAAOD,GAAP;AACD,GAhBY,EAiBb;AACEI,IAAAA,GAAG,EAAE,EADP;AAEEI,IAAAA,MAAM,EAAE;AAFV,GAjBa,EAqBbA,MArBF;AAuBA,SAAO,CAAC3B,WAAD,EAAcW,QAAd,CAAP;AACD;;AACD,eAAed,eAAf,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { useEffect, useState, useCallback } from 'react';\r\nimport { initialState } from '../../reducers/productReducer';\r\n\r\nfunction useLocalStorage(key, initialValue) {\r\n  // Should either store products into global context or find a way to retrieve the values from localstorage PLUS re-render on update\r\n  // State to store our value\r\n\r\n  // Pass initial state function to useState so logic is only executed once\r\n\r\n  const [storedValue, setStoredValue] = useState(() => {\r\n    try {\r\n      // Get from local storage by key\r\n\r\n      const item = window.localStorage.getItem(key);\r\n\r\n      // Parse stored json or if none return initialValue\r\n\r\n      return item ? JSON.parse(item) : initialValue;\r\n    } catch (error) {\r\n      // If error also return initialValue\r\n\r\n      console.log(error);\r\n\r\n      return initialValue;\r\n    }\r\n  });\r\n\r\n  // Return a wrapped version of useState's setter function that ...\r\n\r\n  // ... persists the new value to localStorage.\r\n\r\n  const setValue = (value) => {\r\n    try {\r\n      // Allow value to be a function so we have same API as useState\r\n\r\n      const valueToStore =\r\n        value instanceof Function ? value(storedValue) : value;\r\n\r\n      // Save state\r\n\r\n      setStoredValue(valueToStore);\r\n\r\n      // Save to local storage\r\n\r\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\r\n    } catch (error) {\r\n      // A more advanced implementation would handle the error case\r\n\r\n      console.log(error);\r\n    }\r\n  };\r\n  console.log(storedValue);\r\n\r\n  let newValue = storedValue.reduce(\r\n    (acc, curr) => {\r\n      if (curr.sku) {\r\n        var fromMap = acc.map[curr.sku];\r\n        if (!fromMap) {\r\n          acc.map[curr.sku] = fromMap = {\r\n            quanity: 0,\r\n            sku: curr.sku,\r\n          };\r\n          acc.newValue.push(fromMap);\r\n        }\r\n        fromMap.quanity += parseFloat(curr.quanity);\r\n      } else {\r\n        acc.newValue.push(curr);\r\n      }\r\n      return acc;\r\n    },\r\n    {\r\n      map: {},\r\n      result: [],\r\n    }\r\n  ).result;\r\n\r\n  return [storedValue, setValue];\r\n}\r\nexport default useLocalStorage;\r\n\r\n// let values = [];\r\n// function useLocalStorage(key) {\r\n//   const [state, setState] = useState(\r\n//     window.localStorage.getItem(key) !== null || undefined\r\n//       ? window.localStorage.getItem(key)\r\n//       : null\r\n//   );\r\n\r\n//   // Consider just having the key as a useRef with return callbacks for setting and getting data\r\n//   console.log(values);\r\n//   useEffect(() => {\r\n//     window.localStorage.setItem(key, values);\r\n//   }, [key]);\r\n\r\n//   return {\r\n//     state,\r\n//     setState,\r\n//     addValue: useCallback((value) => {\r\n//       values.push(value);\r\n//       console.log(value);\r\n//     }, []),\r\n//   };\r\n// }\r\n"]},"metadata":{},"sourceType":"module"}