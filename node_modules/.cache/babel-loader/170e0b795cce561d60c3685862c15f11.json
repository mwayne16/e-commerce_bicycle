{"ast":null,"code":"import { useEffect, useState, useCallback } from 'react';\nimport { initialState } from '../../reducers/productReducer';\n\nfunction useLocalStorage(key, initialValue) {\n  // Should either store products into global context or find a way to retrieve the values from localstorage PLUS re-render on update\n  // State to store our value\n  // Pass initial state function to useState so logic is only executed once\n  let combineStoredValues = arr => arr.reduce((acc, curr) => {\n    if (curr.sku) {\n      var fromMap = acc.map[curr.sku];\n\n      if (!fromMap) {\n        acc.map[curr.sku] = fromMap = {\n          name: curr.name,\n          sku: curr.sku,\n          quanity: 0\n        };\n        acc.result.push(fromMap);\n      }\n\n      fromMap.quanity += parseFloat(curr.quanity);\n    } else {\n      acc.result.push(curr);\n    }\n\n    return acc;\n  }, {\n    map: {},\n    result: []\n  }).result;\n\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from local storage by key\n      const item = window.localStorage.getItem(key); // Parse stored json or if none return initialValue\n\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      // If error also return initialValue\n      console.log(error);\n      return initialValue;\n    }\n  }); // Return a wrapped version of useState's setter function that ...\n  // ... persists the new value to localStorage.\n\n  const setValue = value => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore = value instanceof Function ? value(storedValue) : value; // Save state\n\n      setStoredValue(valueToStore); // Save to local storage\n\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      // A more advanced implementation would handle the error case\n      console.log(error);\n    }\n  };\n\n  useEffect(() => {\n    setStoredValue(combineStoredValues(storedValue));\n  }, [storedValue]);\n  console.log(storedValue);\n  return [storedValue, setValue];\n}\n\nexport default useLocalStorage; // let values = [];\n// function useLocalStorage(key) {\n//   const [state, setState] = useState(\n//     window.localStorage.getItem(key) !== null || undefined\n//       ? window.localStorage.getItem(key)\n//       : null\n//   );\n//   // Consider just having the key as a usequanity with return callbacks for setting and getting data\n//   console.log(values);\n//   useEffect(() => {\n//     window.localStorage.setItem(key, values);\n//   }, [key]);\n//   return {\n//     state,\n//     setState,\n//     addValue: useCallback((value) => {\n//       values.push(value);\n//       console.log(value);\n//     }, []),\n//   };\n// }","map":{"version":3,"sources":["E:/React_Projects/e-commerce_bicycle/src/components/custom_hooks/useLocalStorage.js"],"names":["useEffect","useState","useCallback","initialState","useLocalStorage","key","initialValue","combineStoredValues","arr","reduce","acc","curr","sku","fromMap","map","name","quanity","result","push","parseFloat","storedValue","setStoredValue","item","window","localStorage","getItem","JSON","parse","error","console","log","setValue","value","valueToStore","Function","setItem","stringify"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,QAApB,EAA8BC,WAA9B,QAAiD,OAAjD;AACA,SAASC,YAAT,QAA6B,+BAA7B;;AAEA,SAASC,eAAT,CAAyBC,GAAzB,EAA8BC,YAA9B,EAA4C;AAC1C;AACA;AAEA;AACA,MAAIC,mBAAmB,GAAIC,GAAD,IACxBA,GAAG,CAACC,MAAJ,CACE,CAACC,GAAD,EAAMC,IAAN,KAAe;AACb,QAAIA,IAAI,CAACC,GAAT,EAAc;AACZ,UAAIC,OAAO,GAAGH,GAAG,CAACI,GAAJ,CAAQH,IAAI,CAACC,GAAb,CAAd;;AACA,UAAI,CAACC,OAAL,EAAc;AACZH,QAAAA,GAAG,CAACI,GAAJ,CAAQH,IAAI,CAACC,GAAb,IAAoBC,OAAO,GAAG;AAC5BE,UAAAA,IAAI,EAAEJ,IAAI,CAACI,IADiB;AAE5BH,UAAAA,GAAG,EAAED,IAAI,CAACC,GAFkB;AAG5BI,UAAAA,OAAO,EAAE;AAHmB,SAA9B;AAKAN,QAAAA,GAAG,CAACO,MAAJ,CAAWC,IAAX,CAAgBL,OAAhB;AACD;;AACDA,MAAAA,OAAO,CAACG,OAAR,IAAmBG,UAAU,CAACR,IAAI,CAACK,OAAN,CAA7B;AACD,KAXD,MAWO;AACLN,MAAAA,GAAG,CAACO,MAAJ,CAAWC,IAAX,CAAgBP,IAAhB;AACD;;AACD,WAAOD,GAAP;AACD,GAjBH,EAkBE;AACEI,IAAAA,GAAG,EAAE,EADP;AAEEG,IAAAA,MAAM,EAAE;AAFV,GAlBF,EAsBEA,MAvBJ;;AAyBA,QAAM,CAACG,WAAD,EAAcC,cAAd,IAAgCpB,QAAQ,CAAC,MAAM;AACnD,QAAI;AACF;AAEA,YAAMqB,IAAI,GAAGC,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4BpB,GAA5B,CAAb,CAHE,CAKF;;AAEA,aAAOiB,IAAI,GAAGI,IAAI,CAACC,KAAL,CAAWL,IAAX,CAAH,GAAsBhB,YAAjC;AACD,KARD,CAQE,OAAOsB,KAAP,EAAc;AACd;AAEAC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AAEA,aAAOtB,YAAP;AACD;AACF,GAhB6C,CAA9C,CA9B0C,CAgD1C;AAEA;;AAEA,QAAMyB,QAAQ,GAAIC,KAAD,IAAW;AAC1B,QAAI;AACF;AAEA,YAAMC,YAAY,GAChBD,KAAK,YAAYE,QAAjB,GAA4BF,KAAK,CAACZ,WAAD,CAAjC,GAAiDY,KADnD,CAHE,CAMF;;AAEAX,MAAAA,cAAc,CAACY,YAAD,CAAd,CARE,CAUF;;AAEAV,MAAAA,MAAM,CAACC,YAAP,CAAoBW,OAApB,CAA4B9B,GAA5B,EAAiCqB,IAAI,CAACU,SAAL,CAAeH,YAAf,CAAjC;AACD,KAbD,CAaE,OAAOL,KAAP,EAAc;AACd;AAEAC,MAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD;AACF,GAnBD;;AAoBA5B,EAAAA,SAAS,CAAC,MAAM;AACdqB,IAAAA,cAAc,CAACd,mBAAmB,CAACa,WAAD,CAApB,CAAd;AACD,GAFQ,EAEN,CAACA,WAAD,CAFM,CAAT;AAGAS,EAAAA,OAAO,CAACC,GAAR,CAAYV,WAAZ;AACA,SAAO,CAACA,WAAD,EAAcW,QAAd,CAAP;AACD;;AACD,eAAe3B,eAAf,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { useEffect, useState, useCallback } from 'react';\r\nimport { initialState } from '../../reducers/productReducer';\r\n\r\nfunction useLocalStorage(key, initialValue) {\r\n  // Should either store products into global context or find a way to retrieve the values from localstorage PLUS re-render on update\r\n  // State to store our value\r\n\r\n  // Pass initial state function to useState so logic is only executed once\r\n  let combineStoredValues = (arr) =>\r\n    arr.reduce(\r\n      (acc, curr) => {\r\n        if (curr.sku) {\r\n          var fromMap = acc.map[curr.sku];\r\n          if (!fromMap) {\r\n            acc.map[curr.sku] = fromMap = {\r\n              name: curr.name,\r\n              sku: curr.sku,\r\n              quanity: 0,\r\n            };\r\n            acc.result.push(fromMap);\r\n          }\r\n          fromMap.quanity += parseFloat(curr.quanity);\r\n        } else {\r\n          acc.result.push(curr);\r\n        }\r\n        return acc;\r\n      },\r\n      {\r\n        map: {},\r\n        result: [],\r\n      }\r\n    ).result;\r\n\r\n  const [storedValue, setStoredValue] = useState(() => {\r\n    try {\r\n      // Get from local storage by key\r\n\r\n      const item = window.localStorage.getItem(key);\r\n\r\n      // Parse stored json or if none return initialValue\r\n\r\n      return item ? JSON.parse(item) : initialValue;\r\n    } catch (error) {\r\n      // If error also return initialValue\r\n\r\n      console.log(error);\r\n\r\n      return initialValue;\r\n    }\r\n  });\r\n\r\n  // Return a wrapped version of useState's setter function that ...\r\n\r\n  // ... persists the new value to localStorage.\r\n\r\n  const setValue = (value) => {\r\n    try {\r\n      // Allow value to be a function so we have same API as useState\r\n\r\n      const valueToStore =\r\n        value instanceof Function ? value(storedValue) : value;\r\n\r\n      // Save state\r\n\r\n      setStoredValue(valueToStore);\r\n\r\n      // Save to local storage\r\n\r\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\r\n    } catch (error) {\r\n      // A more advanced implementation would handle the error case\r\n\r\n      console.log(error);\r\n    }\r\n  };\r\n  useEffect(() => {\r\n    setStoredValue(combineStoredValues(storedValue));\r\n  }, [storedValue]);\r\n  console.log(storedValue);\r\n  return [storedValue, setValue];\r\n}\r\nexport default useLocalStorage;\r\n\r\n// let values = [];\r\n// function useLocalStorage(key) {\r\n//   const [state, setState] = useState(\r\n//     window.localStorage.getItem(key) !== null || undefined\r\n//       ? window.localStorage.getItem(key)\r\n//       : null\r\n//   );\r\n\r\n//   // Consider just having the key as a usequanity with return callbacks for setting and getting data\r\n//   console.log(values);\r\n//   useEffect(() => {\r\n//     window.localStorage.setItem(key, values);\r\n//   }, [key]);\r\n\r\n//   return {\r\n//     state,\r\n//     setState,\r\n//     addValue: useCallback((value) => {\r\n//       values.push(value);\r\n//       console.log(value);\r\n//     }, []),\r\n//   };\r\n// }\r\n"]},"metadata":{},"sourceType":"module"}